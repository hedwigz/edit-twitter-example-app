// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"strconv"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	"github.com/ariga/edit-twitter-example-app/enthistory/ent/entity"
	"github.com/ariga/edit-twitter-example-app/enthistory/ent/history"
)

// Enrich allow modifying how an History node is created
type Enrich func(context.Context, *HistoryCreate) *HistoryCreate

type historyMutator struct {
	mutationEnrich Enrich
}

func NewHistoryMutator(mutationEnrich Enrich) historyMutator {
	return historyMutator{mutationEnrich}
}

// QueryHistory queries the history of Entity.
func (c *EntityClient) QueryHistory(e *Entity) *HistoryQuery {
	query := &HistoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(history.Table, history.FieldRecordID),
			sqlgraph.Edge(sqlgraph.O2M, false, history.Table, history.FieldRecordID),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

func (hm historyMutator) EntityHistoryMutateHook(next ent.Mutator) ent.Mutator {
	return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
		if !m.Op().Is(ent.OpCreate | ent.OpUpdateOne) {
			return next.Mutate(ctx, m)
		}
		tm := m.(*EntityMutation)
		prevs := make(map[string]string)
		if prev, err := tm.OldData(ctx); err == nil {
			pv := prev
			prevs["data"] = pv
		}
		if prev, err := tm.OldIsFun(ctx); err == nil {
			pv := "false"
			if prev {
				pv = "true"
			}
			prevs["isFun"] = pv
		}
		if prev, err := tm.OldCounter(ctx); err == nil {
			pv := strconv.FormatInt(int64(prev), 10)
			prevs["counter"] = pv
		}
		if prev, err := tm.OldTimestamp(ctx); err == nil {
			pv := prev.Format(time.RFC3339Nano)
			prevs["timestamp"] = pv
		}
		if prev, err := tm.OldStrings(ctx); err == nil {
			b, err := json.Marshal(prev)
			if err != nil {
				return nil, err
			}
			pv := string(b)
			prevs["strings"] = pv
		}
		tx, err := tm.Tx()
		if err != nil {
			return nil, err
		}
		v, err := next.Mutate(ctx, m)
		if err != nil {
			return v, err
		}
		t := v.(*Entity)
		var bulk []*ChangesCreate
		if c, ok := tm.Data(); ok {
			fv := c
			change := tx.Changes.Create().
				SetColumn("data").
				SetValue(fv)
			if prev, ok := prevs["data"]; ok {
				change.SetPrevious(prev)
			}
			bulk = append(bulk, change)
		}
		if c, ok := tm.IsFun(); ok {
			fv := "false"
			if c {
				fv = "true"
			}
			change := tx.Changes.Create().
				SetColumn("isFun").
				SetValue(fv)
			if prev, ok := prevs["isFun"]; ok {
				change.SetPrevious(prev)
			}
			bulk = append(bulk, change)
		}
		if c, ok := tm.Counter(); ok {
			fv := strconv.FormatInt(int64(c), 10)
			change := tx.Changes.Create().
				SetColumn("counter").
				SetValue(fv)
			if prev, ok := prevs["counter"]; ok {
				change.SetPrevious(prev)
			}
			bulk = append(bulk, change)
		}
		if c, ok := tm.Timestamp(); ok {
			fv := c.Format(time.RFC3339Nano)
			change := tx.Changes.Create().
				SetColumn("timestamp").
				SetValue(fv)
			if prev, ok := prevs["timestamp"]; ok {
				change.SetPrevious(prev)
			}
			bulk = append(bulk, change)
		}
		if c, ok := tm.Strings(); ok {
			b, err := json.Marshal(c)
			if err != nil {
				return nil, err
			}
			fv := string(b)
			change := tx.Changes.Create().
				SetColumn("strings").
				SetValue(fv)
			if prev, ok := prevs["strings"]; ok {
				change.SetPrevious(prev)
			}
			bulk = append(bulk, change)
		}
		if len(bulk) == 0 {
			return v, nil
		}
		changes, err := tx.Changes.CreateBulk(bulk...).Save(ctx)
		if err != nil {
			return nil, err
		}

		action := history.ActionCreate
		if m.Op().Is(ent.OpUpdate | ent.OpUpdateOne) {
			action = history.ActionUpdate
		}

		hc := tx.History.Create().
			AddChanges(changes...).
			SetRecordID(t.ID).
			SetTimestamp(time.Now()).
			SetEntityName("Entity").
			SetAction(action)

		if hm.mutationEnrich != nil {
			hc = hm.mutationEnrich(ctx, hc)
		}

		return v, hc.Exec(ctx)
	})
}

// HookHistory Hooks the ent.Client with all of history mutators.
func HookHistory(client *Client, enrich Enrich) {
	hm := NewHistoryMutator(enrich)
	client.Entity.Use(hm.EntityHistoryMutateHook)
}
